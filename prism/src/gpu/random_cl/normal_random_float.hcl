#ifndef __NORMAL_RANDOM_FLOAT_HCL
#define __NORMAL_RANDOM_FLOAT_HCL


/**
 * @file normal_random_float.hcl
 * 
 * @brief This header implements functions to generate normally distributed random floats. A Box-Muller transform or the Ziggurat algorithm can be used for the generation of this random numbers.
 * 
 * @author Philipp Otterbein
 */


#if ((defined ZIGGURAT_NORMAL) || (defined ZIGGURAT_NORMAL_FLOAT))
#include "../ziggurat_consts/ziggurat_normal_consts_f_9.hcl"


float __normal_distr_float( float x )
{
	return exp( -0.5f * x * x );
}


/**
 * \internal
 * This internal function creates a random float from the tail of the normal distribution by using a rejection algorithm
 * @param dest the result is written to \b dest[0]
 * @param rnd array of two exponentially distributed floats
 * @param output specifies whether a result should be written to \b dest
 * @return false when the random numbers are rejected otherwise true
 */
bool fallback_check_float( float *dest, const float *const rnd )
{
	float x = rnd[0] * __ziggurat_normal_inv_x1_float;
	*dest = x + __ziggurat_normal_x1_float;
	return ((rnd[1] + rnd[1]) > x*x);
}


#ifndef ENDIAN_OFFSET
#ifdef __ENDIAN_LITTLE__
	#define ENDIAN_OFFSET 1
#else
	#define ENDIAN_OFFSET 0
#endif
#endif



#define __ziggurat_normal_float( PRNG, T ) \
/** This function generates normally distributed floats with mean 0 and variance 1 by applying the Ziggurat algorithm to pseudo random numbers generated by {@link PRNG##_random##T}. The output has high quality \n @param dest the results are returned in this array. It has to have at least number_of_workgroups * local_work_size * \b rnds_per_workitem elements \n @param tmp_buffer temporary array which has at least number_of_workgroups * (uint)(2 * local_work_size * \b rnds_per_workitem * \b tmp_buffer) elements \n @param ptr pointer to __local storage needed for temporary counters \n @param prng PRNG##_PRNG object to use for random number generation \n @param rnds_per_workitem number of random floats each work-item shall generate \n @param tmp_buffer_size fraction of temporary storage, in which numbers, which are not accepted in the first step of the Ziggurat algorithm, are stored, compared to the number of elements of the output array. \n absolutely save: tmp_buffer_size = 1; for large data sets e.g. tmp_buffer_size = 0.05 should be safe, if much memory is needed */ \
inline void PRNG##_ziggurat_normal_float##T( __global float *dest, __global uint *tmp_buffer, __local uint *ptr, PRNG##_PRNG prng, const uint rnds_per_workitem, const float tmp_buffer_size ) \
{ \
	__global uint *const local_buffer = tmp_buffer + __rnd_get_group_id() * (uint)(2 * __rnd_get_workgroup_size() * rnds_per_workitem * tmp_buffer_size); \
	\
	{ \
		ptr[0] = 0; \
		ptr[1] = (uint)(2 * __rnd_get_workgroup_size() * rnds_per_workitem * tmp_buffer_size) - 1; \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		uint offset = __rnd_get_group_id() * __rnd_get_workgroup_size() * rnds_per_workitem + __rnd_get_local_id() - __rnd_get_workgroup_size(); \
		for( int i = 0; i < rnds_per_workitem; i++ ) \
		{ \
			uint rnd = PRNG##_random##T( prng ); \
			const uint n = rnd >> (32 - __LOG_TBL_LENGTH_FLOAT); \
			rnd &= ~0xff800000; \
			rnd |= 0x40000000; \
			offset += __rnd_get_workgroup_size(); \
			const float u0 = as_float( rnd ) - 3.f; \
			const float x = u0 * __ziggurat_normal_float_tbl_x[n]; \
			dest[offset] = x; \
			const uint abs_x = as_uint(x) & 0x7fffffff; \
			if( abs_x < as_uint(__ziggurat_normal_float_tbl_x[n+1]) ) \
				continue; \
			if( n != 0 ) \
			{ \
				const uint tmp = atomic_inc(ptr); \
				local_buffer[2 * tmp] = offset; \
				local_buffer[2 * tmp + 1] = n; \
			} \
			else \
				local_buffer[atomic_dec(ptr + 1)] = offset; \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
	} \
	\
	do \
	{ \
		{ /*this block checkes whether a sample belongs to the normal distribution*/ \
			__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
			const uint count = ptr[0]; \
			__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
			const uint max = ((count + __rnd_get_workgroup_size() - 1) / __rnd_get_workgroup_size()) * __rnd_get_workgroup_size(); \
			ptr[0] = 0; \
			__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
			for( int i = __rnd_get_local_id(); i < max; i += __rnd_get_workgroup_size() ) \
			{ \
				const uint idx = 2 * i * (i < count); \
				const uint pos = local_buffer[idx]; \
				const uint n = local_buffer[idx + 1]; \
				const float y = __ziggurat_normal_float_tbl_y[n] + PRNG##_rndFloat##T( prng ) * (__ziggurat_normal_float_tbl_y[n+1] - __ziggurat_normal_float_tbl_y[n]); \
				const float x = dest[pos]; \
				__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
				if( (y >= __normal_distr_float(x)) & (i < count) ) \
					local_buffer[2 * atomic_inc(ptr)] = pos; \
				__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
			} \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		const uint count = ptr[0]; \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		const uint max = ((count + __rnd_get_workgroup_size() - 1) / __rnd_get_workgroup_size()) * __rnd_get_workgroup_size(); \
		ptr[0] = 0; \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		for( int i = __rnd_get_local_id(); i < max; i += __rnd_get_workgroup_size() ) \
		{ \
			__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
			const uint pos = local_buffer[2 * i * (i < count)]; \
			uint rnd = PRNG##_random##T( prng ); \
			__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
			const uint n = rnd >> (32 - __LOG_TBL_LENGTH_FLOAT); \
			rnd &= ~0xff800000; \
			rnd |= 0x40000000; \
			const float u0 = as_float( rnd ) - 3.f; \
			const float x = u0 * __ziggurat_normal_float_tbl_x[n]; \
			if( i < count ) \
			{ \
				dest[pos] = x; \
				if( fabs(x) >= __ziggurat_normal_float_tbl_x[n+1] ) \
				{ \
					if( n != 0 ) \
					{ \
						const uint tmp = atomic_inc(ptr); \
						local_buffer[2*tmp] = pos; \
						local_buffer[2*tmp + 1] = n; \
					} \
					else \
						local_buffer[atomic_dec(ptr + 1)] = pos; \
				} \
			} \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
	} while( ptr[0] > 0 ); \
	\
	{ /*This block samples the tail of the normal distribution*/  \
		const uint count = (uint)(2 * __rnd_get_workgroup_size() * rnds_per_workitem * tmp_buffer_size) - 1 - ptr[1]; \
		const uint max = ((count + __rnd_get_workgroup_size() - 1) / __rnd_get_workgroup_size()) * __rnd_get_workgroup_size(); \
		for( int i = __rnd_get_local_id(); i < max; i += __rnd_get_workgroup_size() ) \
		{ \
			const uint pos = local_buffer[ptr[1] + i * (i < count)]; \
			float tmp; \
			PRNG##_generic_rejection_complex( float, PRNG##_exp_distr_float##T, &tmp, prng, 2, fallback_check_float ); \
			uint sign = PRNG##_random##T( prng ) & 0x80000000; \
			if( (i < count) ) \
				dest[pos] = as_float( as_uint(tmp) | sign ); \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
	} \
}

#define __ziggurat_normal_float_kernel( PRNG, T ) \
void PRNG##_ziggurat_normal_float##T##_kernel( __global float *dest, __global uint *tmp_buffer, PRNG##_state state, const uint rnds_per_workitem, const float tmp_buffer_size ) \
{ \
	__local uint ptr[2]; \
	PRNG##_init( prng, state ); \
	PRNG##_ziggurat_normal_float##T( dest, tmp_buffer, ptr, prng, rnds_per_workitem, tmp_buffer_size ); \
	PRNG##_save( prng ); \
}

#endif



#define __box_muller_float_fast( PRNG, T ) \
/** This function generates two normally distributed floats with mean 0 and variance 1 by applying the Box-Muller transform to outputs of {@link PRNG##_random##T}. It uses native functions so that the accuracy is hardware dependent and the resolution of the sampled floats decreases with increasing absolute value. \n @param dest the result is saved in the array pointed to by \b dest \n @param prng the PRNG##_PRNG object to use for random number generation */ \
inline void PRNG##_box_muller_float##T##_fast( float dest[2], PRNG##_PRNG prng ) \
{ \
	float rnd1 = -native_log( PRNG##_rndFloat##T( prng ) ); \
	float rnd2 = PRNG##_rndFloat##T( prng ); \
	float factor = native_sqrt( rnd1 + rnd1 ); \
	dest[0] = factor * native_cos( 2.f * M_PI_F * rnd2 ); \
	dest[1] = factor * native_sin( 2.f * M_PI_F * rnd2 ); \
}


#define __box_muller_float_native( PRNG, T ) \
/** This function generates two normally distributed floats with mean 0 and variance 1 by applying the Box-Muller transform to outputs of {@link PRNG##_random##T}. It uses native functions so that the accuracy is hardware dependent. \n @param dest the result is saved in the array pointed to by \b dest \n @param prng the PRNG##_PRNG object to use for random number generation */ \
inline void PRNG##_box_muller_float##T##_native( float dest[2], PRNG##_PRNG prng ) \
{ \
	float rnd1 = PRNG##_exp_distr_float##T##_native( prng ); \
	float rnd2 = PRNG##_rndFloat##T( prng ); \
	float factor = native_sqrt( rnd1 + rnd1 ); \
	dest[0] = factor * native_cos( 2.f * M_PI_F * rnd2 ); \
	dest[1] = factor * native_sin( 2.f * M_PI_F * rnd2 ); \
}



#define __box_muller_float( PRNG, T ) \
/** This function generates two normally distributed floats with mean 0 and variance 1 by applying the Box-Muller transform to outputs of {@link PRNG##_random##T}. \n @param dest the result is saved in the array pointed to by \b dest \n @param prng the PRNG##_PRNG object to use for random number generation */ \
inline void PRNG##_box_muller_float##T( float dest[2], PRNG##_PRNG prng ) \
{ \
	float rnd1 = PRNG##_exp_distr_float##T( prng ); \
	float rnd2 = PRNG##_rndFloat##T( prng ); \
	float factor = sqrt( rnd1 + rnd1 ); \
	dest[0] = factor * cos( 2.f * M_PI_F * rnd2 ); \
	dest[1] = factor * sin( 2.f * M_PI_F * rnd2 ); \
}

#endif