#ifndef __NORMAL_RANDOM_DOUBLE_HCL
#define __NORMAL_RANDOM_DOUBLE_HCL

/**
 * @file normal_random_double.hcl
 * 
 * @brief This header implements functions to generate normally distributed random doubles. A Box-Muller transform or the Ziggurat algorithm can be used for the generation of this random numbers.
 * 
 * @author Philipp Otterbein
 */


#if ((defined ZIGGURAT_NORMAL) || (defined ZIGGURAT_NORMAL_DOUBLE))
#include "../ziggurat_consts/ziggurat_normal_consts_10.hcl"


double __normal_distr_double( double x )
{
	return exp( -0.5 * x * x );
}



/**
 * \internal
 * This internal function creates a random double from the tail of the normal distribution by using a rejection algorithm
 * @param dest the result is written to \b dest[0]
 * @param rnd array of two exponentially distributed doubles
 * @param output specifies whether a result should be written to \b dest
 * @return false when the random numbers are rejected otherwise true
 */
bool fallback_check_double( double *dest, const double *const rnd )
{
	double x = rnd[0] * __ziggurat_normal_inv_x1_double;
	*dest = x + __ziggurat_normal_x1_double;
	return ((rnd[1] + rnd[1]) > x*x);
}


#ifndef ENDIAN_OFFSET
#ifdef __ENDIAN_LITTLE__
	#define ENDIAN_OFFSET 1
#else
	#define ENDIAN_OFFSET 0
#endif
#endif


#define __ziggurat_normal_double( PRNG, T ) \
/** This function generates normally distributed doubles with mean 0 and variance 1 by applying the Ziggurat algorithm to pseudo random numbers generated by {@link PRNG##_random##T}. The output has high quality \n @param dest the results are returned in this array. It has to have at least number_of_workgroups * local_work_size * \b rnds_per_workitem elements \n @param tmp_buffer temporary array which has at least number_of_workgroups * (uint)(2 * local_work_size * \b rnds_per_workitem * \b tmp_buffer) elements \n @param ptr pointer to __local storage needed for temporary counters \n @param prng PRNG##_PRNG object to use for random number generation \n @param rnds_per_workitem number of random doubles each work-item shall generate \n @param tmp_buffer_size fraction of temporary storage, in which numbers, which are not accepted in the first step of the Ziggurat algorithm, are stored, compared to the number of elements of the output array. \n absolutely save: tmp_buffer_size = 1; for large data sets e.g. tmp_buffer_size = 0.05 should be safe, if much memory is needed */ \
inline void PRNG##_ziggurat_normal_double##T( __global double *dest, __global uint *tmp_buffer, __local uint ptr[2], PRNG##_PRNG prng, const uint rnds_per_workitem, const float tmp_buffer_size ) \
{ \
	__global uint *const local_buffer = tmp_buffer + __rnd_get_group_id() * (uint)(2 * __rnd_get_workgroup_size() * rnds_per_workitem * tmp_buffer_size); \
	\
	{ \
		ptr[0] = 0; \
		ptr[1] = (uint)(2 * __rnd_get_workgroup_size() * rnds_per_workitem * tmp_buffer_size) - 1; \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		const uint max = (__rnd_get_group_id() + 1) * __rnd_get_workgroup_size() * rnds_per_workitem; \
		for( uint i = __rnd_get_group_id() * __rnd_get_workgroup_size() * rnds_per_workitem + __rnd_get_local_id(); i < max; i += __rnd_get_workgroup_size() ) \
		{ \
			uint rnd1 = PRNG##_random##T( prng ); \
			const uint n = rnd1 >> (32 - __LOG_TBL_LENGTH_DOUBLE); \
			rnd1 &= ~0xfff00000; \
			rnd1 |= 0x40000000; \
			const uint rnd2 = PRNG##_random##T( prng ); \
			const double u0 = as_double( ((ulong) rnd1 << 32) | rnd2 ) - 3.; \
			const double x = u0 * __ziggurat_normal_double_tbl_x[n]; \
			dest[i] = x; \
			const uint abs_x = (as_ulong(x) >> 32) & 0x7fffffff; \
			if( abs_x < /* *((uint __constant*)__ziggurat_normal_double_tbl_x + 2*n + 2 + ENDIAN_OFFSET)*/ (uint)(as_ulong(__ziggurat_normal_double_tbl_x[n+1]) >> 32) ) \
				continue; \
			if( n != 0 ) \
			{ \
				const uint tmp = atomic_inc(ptr); \
				local_buffer[2 * tmp] = i; \
				local_buffer[2 * tmp + 1] = n; \
			} \
			else \
				local_buffer[atomic_dec(ptr + 1)] = i; \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
	} \
	\
	do \
	{ \
		{ /*this block checkes whether a sample belongs to the normal distribution*/ \
			__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
			const uint count = ptr[0]; \
			__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
			const uint max = ((count + __rnd_get_workgroup_size() - 1) / __rnd_get_workgroup_size()) * __rnd_get_workgroup_size(); \
			ptr[0] = 0; \
			__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
			for( int i = __rnd_get_local_id(); i < max; i += __rnd_get_workgroup_size() ) \
			{ \
				const uint idx = 2 * i * (i < count); \
				const uint pos = local_buffer[idx]; \
				const uint n = local_buffer[idx + 1]; \
				const double y = __ziggurat_normal_double_tbl_y[n] + PRNG##_rndDouble##T( prng ) * (__ziggurat_normal_double_tbl_y[n+1] - __ziggurat_normal_double_tbl_y[n]); \
				const double x = dest[pos]; \
				__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
				if( (y >= __normal_distr_double(x)) & (i < count) ) \
					local_buffer[2 * atomic_inc(ptr)] = pos; \
				__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
			} \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		const uint count = ptr[0]; \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		const uint max = ((count + __rnd_get_workgroup_size() - 1) / __rnd_get_workgroup_size()) * __rnd_get_workgroup_size(); \
		ptr[0] = 0; \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
		for( int i = __rnd_get_local_id(); i < max; i += __rnd_get_workgroup_size() ) \
		{ \
			__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
			const uint pos = local_buffer[2 * i * (i < count)]; \
			uint rnd1 = PRNG##_random##T( prng ); \
			__rnd_barrier( CLK_GLOBAL_MEM_FENCE ); \
			const uint n = rnd1 >> (32 - __LOG_TBL_LENGTH_DOUBLE); \
			rnd1 &= ~0xfff00000; \
			rnd1 |= 0x40000000; \
			const uint rnd2 = PRNG##_random##T( prng ); \
			const double u0 = as_double( ((ulong) rnd1 << 32) | rnd2 ) - 3.; \
			const double x = u0 * __ziggurat_normal_double_tbl_x[n]; \
			if( i < count ) \
			{ \
				dest[pos] = x; \
				if( fabs(x) >= __ziggurat_normal_double_tbl_x[n+1] ) \
				{ \
					if( n != 0 ) \
					{ \
						const uint tmp = atomic_inc(ptr); \
						local_buffer[2*tmp] = pos; \
						local_buffer[2*tmp + 1] = n; \
					} \
					else \
						local_buffer[atomic_dec(ptr + 1)] = pos; \
				} \
			} \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
	} while( ptr[0] > 0 ); \
	\
	{ /*This block samples the tail of the normal distribution*/ \
		const uint count = (uint)(2 * __rnd_get_workgroup_size() * rnds_per_workitem * tmp_buffer_size) - 1 - ptr[1]; \
		const uint max = ((count + __rnd_get_workgroup_size() - 1) / __rnd_get_workgroup_size()) * __rnd_get_workgroup_size(); \
		for( int i = __rnd_get_local_id(); i < max; i += __rnd_get_workgroup_size() ) \
		{ \
			const uint pos = local_buffer[ptr[1] + i * (i < count)]; \
			double tmp; \
			PRNG##_generic_rejection_complex( double, PRNG##_exp_distr_double##T, &tmp, prng, 2, fallback_check_double ); \
			ulong sign = (ulong)(PRNG##_random##T( prng ) & 0x80000000) << 32; \
			if( (i < count) & (fabs(dest[pos]) >= __ziggurat_normal_double_tbl_x[1]) ) \
				dest[pos] = as_double( as_ulong(tmp) | sign ); \
		} \
		__rnd_barrier( CLK_LOCAL_MEM_FENCE ); \
	} \
}

#define __ziggurat_normal_double_kernel( PRNG, T ) \
void PRNG##_ziggurat_normal_double##T##_kernel( __global double *dest, __global uint *tmp_buffer, PRNG##_state state, const uint rnds_per_workitem, const float tmp_buffer_size ) \
{ \
	__local uint ptr[2]; \
	PRNG##_init( prng, state ); \
	PRNG##_ziggurat_normal_double##T( dest, tmp_buffer, ptr, prng, rnds_per_workitem, tmp_buffer_size ); \
	PRNG##_save( prng ); \
}

#endif



#define __box_muller_double( PRNG, T ) \
/** This function generates two normally distributed doubles with mean 0 and variance 1 by applying the Box-Muller transform to outputs of {@link PRNG##_random##T}. \n @param dest the result is saved in the array pointed to by \b dest \n @param prng the PRNG##_PRNG object to use for random number generation */ \
inline void PRNG##_box_muller_double##T( double dest[2], PRNG##_PRNG prng ) \
{ \
	double rnd1 = PRNG##_exp_distr_double##T( prng ); \
	double rnd2 = PRNG##_rndDouble##T( prng ); \
	double factor = sqrt( rnd1 + rnd1 ); \
	dest[0] = factor * cos( 2. * M_PI * rnd2 ); \
	dest[1] = factor * sin( 2. * M_PI * rnd2 ); \
}


#define __box_muller_double_fast( PRNG, T ) \
/** This function generates two normally distributed doubles with mean 0 and variance 1 by applying the Box-Muller transform to outputs of {@link PRNG##_random##T}. The resolution of sampled numbers decreases with its absolute value. \n @param dest the result is saved in the array pointed to by \b dest \n @param prng the PRNG##_PRNG object to use for random number generation */ \
inline void PRNG##_box_muller_double##T##_fast( double dest[2], PRNG##_PRNG prng ) \
{ \
	double rnd1 = -log( PRNG##_rndDouble##T( prng ) ); \
	double rnd2 = PRNG##_rndDouble##T( prng ); \
	double factor = sqrt( rnd1 + rnd1 ); \
	dest[0] = factor * cos( 2. * M_PI * rnd2 ); \
	dest[1] = factor * sin( 2. * M_PI * rnd2 ); \
}

#endif